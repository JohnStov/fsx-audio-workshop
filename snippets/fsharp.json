{
	"Basic Noise Provider": {
		"prefix": "aud1",
		"body": [
			"module AudioPlayground",
			"",
			"open NAudio.Wave",
			"open System",
			"open NAudio.CoreAudioApi",
			"open System.Threading",
			"",
			"type NoiseProvider () =",
			"    // samplerate:44.1kHz, mono",
			"    let waveFormat = WaveFormat.CreateIeeeFloatWaveFormat(44100, 1)",
			"    let bytesPerSample = waveFormat.BitsPerSample / 8",
			"    let random = Random()",
			"",
			"    interface IWaveProvider with",
			"        member __.WaveFormat with get() = waveFormat",
			"",
			"        member __.Read (buffer, offset, count) =",
			"            let mutable writeIndex = 0",
			"            let putSample sample buffer =",
			"                // convert float to byte array",
			"                let bytes = BitConverter.GetBytes((float32)sample)",
			"                // blit into correct position in buffer",
			"                Array.blit bytes 0 buffer (offset + writeIndex) bytes.Length",
			"                // update position",
			"                writeIndex <- writeIndex + bytes.Length",
			"",
			"            let nSamples = count / bytesPerSample",
			"            let rescale value = (value * 2.0) - 1.0",
			"            for _ in [0 .. nSamples - 1] do",
			"                let sample = random.NextDouble() |> rescale",
			"                putSample sample buffer",
			"            // return the number of bytes written",
			"            nSamples * bytesPerSample",
			"",
			"[<EntryPoint>]",
			"let main _ =",
			"    let output = new WasapiOut(AudioClientShareMode.Shared, 1)",
			"    NoiseProvider () |> output.Init",
			"    output.Play ()",
			"    Thread.Sleep 2000",
			"    output.Stop ()",
			"    0"
		],
		"description": "Initial monolithic noise generator"
	},
	"Array Provider": {
		"prefix": "aud2",
		"body": [
			"module AudioPlayground",
			"",
			"open NAudio.Wave",
			"open System",
			"open NAudio.CoreAudioApi",
			"open System.Threading",
			"",
			"type AudioStream = float array",
			"",
			"type StreamProvider (waveform: AudioStream) =",
			"    // samplerate:44.1kHz, mono",
			"    let waveFormat = WaveFormat.CreateIeeeFloatWaveFormat(44100, 1)",
			"    let bytesPerSample = waveFormat.BitsPerSample / 8",
			"    let mutable readIndex = 0",
			"",
			"    interface IWaveProvider with",
			"        member __.WaveFormat with get() = waveFormat",
			"",
			"        member __.Read (buffer, offset, count) =",
			"            let mutable writeIndex = 0",
			"            let putSample sample buffer =",
			"                // convert float to byte array",
			"                let bytes = BitConverter.GetBytes((float32)sample)",
			"                // blit into correct position in buffer",
			"                Array.blit bytes 0 buffer (offset + writeIndex) bytes.Length",
			"                // update position",
			"                writeIndex <- writeIndex + bytes.Length",
			"",
			"            let nSamples = count / bytesPerSample",
			"            for _ in [0 .. nSamples - 1] do",
			"                // guard against buffer overrun",
			"                let sample = if readIndex < waveform.Length then waveform.[readIndex] else 0.0",
			"                readIndex <- readIndex + 1",
			"                putSample sample buffer",
			"            // return the number of bytes written",
			"            nSamples * bytesPerSample",
			"",
			"let makeNoise nSamples =",
			"    let random = Random()",
			"    let rescale value = (value * 2.0) - 1.0",
			"    Array.init nSamples (fun _ -> random.NextDouble() |> rescale)",
			"",
			"[<EntryPoint>]",
			"let main _ =",
			"    let output = new WasapiOut(AudioClientShareMode.Shared, 1)",
			"    let noise = makeNoise 44100",
			"    noise |> StreamProvider |> output.Init",
			"    output.Play ()",
			"    Thread.Sleep 2000",
			"    output.Stop ()",
			"    0"
		],
		"description": "Array provider"
	},
	"Noise Generator": {
		"prefix": "aud3",
		"body": [
			"module AudioPlayground",
			"",
			"open NAudio.Wave",
			"open System",
			"open NAudio.CoreAudioApi",
			"open System.Threading",
			"",
			"type AudioStream = float seq",
			"",
			"type StreamProvider (waveform: AudioStream) =",
        	"    // samplerate:44.1kHz, mono",
			"    let waveFormat = WaveFormat.CreateIeeeFloatWaveFormat(44100, 1)",
			"    let bytesPerSample = waveFormat.BitsPerSample / 8",
			"    let enumerator = waveform.GetEnumerator()",
			"",
			"    interface IWaveProvider with",
			"        member __.WaveFormat with get() = waveFormat",
			"",
			"        member __.Read (buffer, offset, count) =",
			"            let mutable writeIndex = 0",
			"            let putSample sample buffer =",
			"                // convert float to byte array",
			"                let bytes = BitConverter.GetBytes((float32)sample)",
			"                // blit into correct position in buffer",
			"                Array.blit bytes 0 buffer (offset + writeIndex) bytes.Length",
			"                // update position",
			"                writeIndex <- writeIndex + bytes.Length",
			"",
			"                let nSamples = count / bytesPerSample",
			"                for _ in [1 .. nSamples] do",
			"                    let sample = if enumerator.MoveNext() then enumerator.Current else 0.0",
			"                    putSample sample buffer",
			"                // return the number of bytes written",
			"                nSamples * bytesPerSample",
			"",
			"let makeNoise =",
			"    let random = Random()",
			"    let rescale value = (value * 2.0) - 1.0",
			"    let rec noise () = ",
			"        seq { ",
			"            yield random.NextDouble() |> rescale",
			"            yield! noise () ",
			"        }",
			"    noise ()",
			"",
			"[<EntryPoint>]",
			"let main _ =",
			"    let output = new WasapiOut(AudioClientShareMode.Shared, 1)",
			"    makeNoise |> StreamProvider |> output.Init",
			"    output.Play ()",
			"    Thread.Sleep 2000",
			"    output.Stop ()",
			"    0"
		],
		"description": "Noise generator using seq"
	},
	"Time limited noise": {
		"prefix": "aud3a",
		"body": [
			"let makeNoise1Sec =",
    		"    makeNoise |> Seq.take 44100"
		],
		"description": "1 second of noise"
	},
	"Sinewave": {
		"prefix": "aud4",
		"body": [
			"let TWOPI = 2.0 * Math.PI",
			"",
			"let makeSine sampleRate frequency = ",
			"    let delta = TWOPI * frequency / float sampleRate",
			"    let gen theta = Some (Math.Sin theta, (theta + delta) % TWOPI)",
			"    Seq.unfold gen 0.0"
		],
		"description": "Basic sinewave generator"
	},
	"Generalised wave generator": {
		"prefix": "aud4a",
		"body": [
			"let sampleRate = 44100",
			"",
			"let generate fn sampleRate frequency =",
			"    let delta = TWOPI * frequency / float sampleRate",
			"    let gen theta = Some (fn theta, (theta + delta) % TWOPI)",
			"    Seq.unfold gen 0.0",
			"",
			"let makeSine = generate Math.Sin sampleRate",
			"",
			"let makeSquare =",
			"    let square theta =",
			"        if theta < Math.PI then -1.0 else 1.0",
			"     generate square sampleRate",
			"",
			"let makeSawtooth =",
  			"    let sawtooth theta =",
			"        (theta / Math.PI) - 1.0",
			"    generate sawtooth sampleRate"
		],
		"description": "Generalised waveform generator"
	},
	"Pluck": {
		"prefix": "aud5",
		"body": [
			"let pluck sampleRate frequency =",
			"// frequency is determined by the length of the buffer",
			"let bufferLength = sampleRate / int frequency",
			"// start with noise",
			"let buffer = makeNoise |> Seq.take bufferLength |> Seq.toArray",
			"// go round the buffer repeatedly, playing each sample, ",
			"// then averaging with previous and decaying",
			"let gen index =",
			"    let nextIndex = (index + 1) % bufferLength",
			"    let value = buffer.[nextIndex]",
			"    buffer.[nextIndex] <- (value + buffer.[index]) / 2.0 * 0.996",
			"    Some(value, nextIndex)",
			"Seq.unfold gen (bufferLength - 1)"
		],
		"description": "The Karplus-Strong algorithm"
	},
	"Variable Frequency Control": {
		"prefix": "aud6",
		"body": [
			"let generate fn sampleRate (frequency : AudioStream) = ",
			"    let enumerator = frequency.GetEnumerator()",
			"    let gen theta = ",
			"        let f = if enumerator.MoveNext() then enumerator.Current else 0.0",
			"        let delta = TWOPI * f / float sampleRate",
			"        Some (fn theta, (theta + delta) % TWOPI)",
			"    Seq.unfold gen 0.0",
			"",
			"let Constant value =",
			"    Seq.unfold (fun _ -> Some(value, ())) ()",
			"",
			"let sin440 = makeSine (Constant 440.0)"
		],
		"description": "Variable frequency input"
	},
	"Vibrato": {
		"prefix": "aud6a",
		"body": [
			"let vibrato =",
			"    let sin = makeSine (Constant 3.0)",
			"    sin |> Seq.map (fun x -> (x * 20.0) + 440.0)",
			"",
			"let wobblySine =",
			"    vibrato |> makeSine"
		],
		"description": "Apply vibrato at 3 Hz"
	},
	"Audio input": {
		"prefix": "aud7",
		"body": [
			"let getInDevice () = ",
			"    let deviceRange = [0..MidiIn.NumberOfDevices-1]",
			"    match deviceRange |> List.tryFind (fun n -> MidiIn.DeviceInfo(n).ProductName = \"MPKmini2\") with",
			"    | Some id -> ",
			"      printfn \"Play some music\"",
			"      Some (new MidiIn(id))",
			"    | None -> ",
			"      printfn \"You forgot to plug in the keyboard\"",
			"      None"
		],
		"description": "Audio input selector"
	},
	"Note event to frequency": {
		"prefix": "aud8",
		"body": [
			"let noteStream (evt : IObservable<NoteEvent>) = ",
			"    let mutable note = 0",
			"    let noteNumberToFrequency noteNumber =",
			"        match noteNumber with",
			"        | 0 -> 0.0",
			"        | _ -> Math.Pow(2.0, (float (noteNumber-69)) / 12.0) * 440.0",
			"",
			"    evt.Add(fun event ->",
			"        note <- match event with ",
			"                | NoteOff _ ->  0",
			"                | NoteOn n -> n.NoteNumber",
			"                | _ -> note)",
			"",
			"    Seq.unfold (fun _ -> Some(noteNumberToFrequency note, ())) ()"
		],
		"description": "Note event to frequency stream"
	}
}